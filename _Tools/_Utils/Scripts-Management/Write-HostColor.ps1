

<#
.SYNOPSIS
 Окраска строки с текстом и/или фона, с помощью Write-Host.
 Сделана для обработки подготовленных меню для скриптов AutoSettingsPS и RepackWIMPS.

.DESCRIPTION
 Окраску можно делать с разными фонами и цветом текста в одной строке!
 Синтаксис:
 #<FgСolor>[:<BgСolor>]# <Текст для окраски> #

 Параметры цвета и сам текст должны быть записаны между символов решетки '#'.
 <FgСolor> и <BgСolor> должны быть действительными цветами [ConsoleColor].
 Можно указать только цвет букв, можно только цвет фона.
 Примеры записи:

 #Green#Текст#              | У 'Текст' Цвет букв будет зелёный, а фон дефолный (обычно синий).
 #:Red# Текст #             | У ' Текст ' Цвет Фона будет красный, а цвет букв будет дефолтный (обычно белый или серый).
 #Yellow:DarkCyan# Текст #  | У ' Текст ' Цвет букв будет Жёлтый, а цвет Фона тёмно голубой.

 #Yellow:DarkCyan# Этот текст Жёлтый на тёмно голубом # Этот текст с Обычным цветом #DarkCyan:Yellow# Этот текст Тёмно голубой на жёлтом #

.PARAMETER ForegroundColor
 Задает цвет для букв. По умолчанию будет дефолный параметр цвета.
 Он будет подставлен для всех отрезков текста, к которым не заданы цвета.
 Используется аналогично Write-Host, но не обязателен.

.PARAMETER BackgroundColor
 Задает цвет для фона. По умолчанию будет дефолный параметр цвета.
 Он будет подставлен для всех отрезков текста, к которым не заданы цвета.
 Используется аналогично Write-Host, но не обязателен.

.PARAMETER NoNewline
 Указывает не делать перевод на новую строку после выполнения.
 Используется аналогично Write-Host, но не обязателен.

.EXAMPLE
    Write-HostColor '#Green#Текст#'

    Описание
    --------
    Выведет на экран зеленое слово 'Текст'.

.EXAMPLE
    Write-HostColor '#:Red# Текст #'

    Описание
    --------
    Выведет на экран слово ' Текст ', с красным фоном.

.EXAMPLE
    Write-HostColor '#:Red# Текст #' -NoNewline

    Описание
    --------
    Выведет на экран слово ' Текст ', с красным фоном.
    Без перевода на новую строку.

.EXAMPLE
    Write-HostColor '#Yellow:DarkCyan# Раз # Два #DarkCyan:Yellow# Три #'

    Описание
    --------
    Выведет на экран три слова в одной строке: Раз  Два  Три
    ' Раз ' - Будет Жёлтым цветом на тёмно голубом фоне.
    ' Два ' - Будет дефолным цветом текста и фона.
    ' Три ' - Будет тёмно голубым цветом на жёлтом фоне.

.EXAMPLE
    Write-HostColor $ArrayString

    Описание
    --------
    Выведет массив строк на экран в одну строку: Раз  Два  Три
    если $ArrayString = '#Yellow:DarkCyan# Раз #', 'Два', '#DarkCyan:Yellow# Три #'
    Каждый со своей окраской.

.EXAMPLE
    Write-HostColor "Test" -ForegroundColor White -BackgroundColor DarkBlue

    Описание
    --------
    Выведет на экран строку "Test" также как и Write-Host.
    Можно и так: Write-HostColor "Test"

.NOTES
 ================================================================================
     Автор:  westlife (ru-board)    Версия 1.0
      Дата:  20-08-2018
       Доп:  Переделал из функции Write-HostColored, неизвестного мне автора.
 ================================================================================

#>
Function Write-HostColor {

    [CmdletBinding()]
    param(
        [parameter( Mandatory = $false, ValueFromPipeline = $true, Position = 0 )]
        [string[]] $Text  # Строка или массив из строк.
       ,
        [Parameter( Mandatory = $false, ValueFromPipeline = $true, Position = 1 )]
        [ConsoleColor] $ForegroundColor = $host.UI.RawUI.ForegroundColor  # По умолчанию дефолный параметр цвета для текста.
       ,
        [Parameter( Mandatory = $false, ValueFromPipeline = $true, Position = 2 )]
        [ConsoleColor] $BackgroundColor = $host.UI.RawUI.BackgroundColor  # По умолчанию дефолный параметр цвета для фона.
       ,
        [Parameter( Mandatory = $false )]
        [switch] $NoNewline
    )

    Begin
    {
        # Если строка с текстом существует.
        if ( $null -ne $Text )
        {
            # Если строка передана как массив из строк, то она будет соединена в одну строку через пробел.
            [string] $TextString = $Text -join ' '
        }
    }

    Process
    {
        # Если строка существует.
        if ( $TextString ) {

            # Установка текущих параметров цвета для текста и фона на значения цвета по умолчанию.
            [ConsoleColor] $CurrentFgColor = $ForegroundColor
            [ConsoleColor] $CurrentBgColor = $BackgroundColor

            # Создаем массив из текстовой строки, разделенной на отрезки по символам решетки '#'.
            [string[]] $StringSegments = $TextString.split('#')

            # Было ли в предыдущем цикле foreach совпадение с параметром цвета у отрезка $Segment.
            [bool] $PreviousWasValueColor = $false

            # Поочередное определение у отрезков $Segment строки групп параметров цвета текста и фона и самого текста для окраски, и вывод на экран.
            # Если будет совпадение у отрезка с названиями цветов, то цикл будет перенаправлен к проверке следующего отрезка $Segment,
            # а не прдолжен для попытки вывода результата на экран.
            foreach ( $Segment in $StringSegments )
            {
                # Если в предыдущем цикле не было параметров цвета и отрезок $Segment совпадает с шаблоном записи цвета,
                # например: 'Yellow', 'White:Green' или ':Red'.
                if (( -not $PreviousWasValueColor ) -and ( $Segment -match '^([a-z]*)(:([a-z]+))?$' ))
                {
                    # Cоздаем переменную с цветом для текста из второй группы шаблона совпадений.
                    try {
                        $CurrentFgColor = [ConsoleColor] $matches[1]

                        # Если не будет ошибки, то совпадение с параметром цвета будет True.
                        $PreviousWasValueColor = $true
                    } catch {}

                    # Если есть четвертая группа в совпадении с шаблоном записи цвета,
                    # то создаем переменную с цветом для фона.
                    if ( $matches[3] )
                    {
                        try {
                            $CurrentBgColor = [ConsoleColor] $matches[3]

                            # Если не будет ошибки, то совпадение с параметром цвета будет True.
                            $PreviousWasValueColor = $true
                        } catch {}
                    }

                    # Если хоть одна переменная с цветом была создана в этом цикле foreach.
                    if ( $PreviousWasValueColor )
                    {
                        # Переходим к следующему отрезку $Segment в foreach,
                        # для получения текста для окраски, указанной после цвета. А не продолжаем для вывода на экран!
                        # Так как правило записи - Первый параметр цвета, Второй сам текст для окраски.
                        Continue
                    }
                }

                # Далее если не было совпадений с параметрами цвета, или уже получены и параметры цвета и сам текст.
                # Для вывода результата на экран, если есть что выводить!

                # Оба отрезка с цветом и текстом проверены, сбрасываем наличие совпадений с параметром цвета для возможности следующей проверки в цикле foreach.
                $PreviousWasValueColor = $false

                # Если существует отрезок строки для вывода, текст указанный после параметра цвета.
                if ( $Segment )
                {
                    # Очищаем хэш-таблицу перед добавлением аргументов с параметрами для цвета текста и фона для Write-Host.
                    [hashtable] $ArgsColorHash = @{}

                    # Добавляем в хэш-таблицу аргументы цвета для Write-Host.
                    # Кроме значений '-1'. Такие значения имеют оба дефолтных параметра "$host.UI.RawUI.ForegroundColor" в PS ISE.
                    if ( [int32] $CurrentFgColor -ne '-1' ) { $ArgsColorHash += @{ 'ForegroundColor' = $CurrentFgColor } }
                    if ( [int32] $CurrentBgColor -ne '-1' ) { $ArgsColorHash += @{ 'BackgroundColor' = $CurrentBgColor } }

                    # Выводим результат на экран: Write-Host <Текст> <аргументы цвета> <Без перевода на новую строку>
                    # Если параметр цвета не совпадет с правильными названиями цвета, то названия эти будут выведены как текст без цвета.
                    Write-Host $Segment @ArgsColorHash -NoNewline
                }

                # Возврат текущих параметров цвета к параметрам цвета по умолчанию.
                $CurrentFgColor = $ForegroundColor
                $CurrentBgColor = $BackgroundColor
            }
        }

        # Сделать переход на новую строку в конце выполнения, если не было указано -NoNewLine.
        if ( -not $NoNewLine ) { Write-Host }
    }
}
